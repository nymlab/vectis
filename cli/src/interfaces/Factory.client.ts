/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.35.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import {
    Binary,
    AuthenticatorType,
    ChainConnection,
    Uint128,
    InstantiateMsg,
    WalletFactoryInstantiateMsg,
    AuthenticatorInstInfo,
    Coin,
    ExecuteMsg,
    FactoryManagementTraitExecMsg,
    CodeIdType,
    FeeType,
    FactoryServiceTraitExecMsg,
    AuthenticatorProvider,
    PluginPermission,
    PluginSource,
    ExecMsg,
    CreateWalletMsg,
    Entity,
    Authenticator,
    PluginInstallParams,
    MigrateWalletMsg,
    RelayTransaction,
    QueryMsg,
    FactoryManagementTraitQueryMsg,
    FactoryServiceTraitQueryMsg,
    QueryMsg1,
    NullableAddr,
    Addr,
    ContractVersion,
    Uint64,
    FeesResponse,
    ArrayOfTupleOfStringAndChainConnection,
    ArrayOfTupleOfUint64AndString,
    NullableString,
} from "./Factory.types";
export interface FactoryReadOnlyInterface {
    contractAddress: string;
    totalCreated: () => Promise<Uint64>;
    defaultProxyCodeId: () => Promise<Uint64>;
    deployer: () => Promise<Addr>;
    supportedChains: ({
        limit,
        startAfter,
    }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<ArrayOfTupleOfStringAndChainConnection>;
    supportedProxies: ({
        limit,
        startAfter,
    }: {
        limit?: number;
        startAfter?: number;
    }) => Promise<ArrayOfTupleOfUint64AndString>;
    fees: () => Promise<FeesResponse>;
    authProviderAddr: ({ ty }: { ty: AuthenticatorType }) => Promise<NullableAddr>;
    contractVersion: () => Promise<ContractVersion>;
    walletByVid: ({ vid }: { vid: string }) => Promise<NullableAddr>;
    walletByVidChain: ({ chainId, vid }: { chainId: string; vid: string }) => Promise<NullableString>;
}
export class FactoryQueryClient implements FactoryReadOnlyInterface {
    client: CosmWasmClient;
    contractAddress: string;

    constructor(client: CosmWasmClient, contractAddress: string) {
        this.client = client;
        this.contractAddress = contractAddress;
        this.totalCreated = this.totalCreated.bind(this);
        this.defaultProxyCodeId = this.defaultProxyCodeId.bind(this);
        this.deployer = this.deployer.bind(this);
        this.supportedChains = this.supportedChains.bind(this);
        this.supportedProxies = this.supportedProxies.bind(this);
        this.fees = this.fees.bind(this);
        this.authProviderAddr = this.authProviderAddr.bind(this);
        this.contractVersion = this.contractVersion.bind(this);
        this.walletByVid = this.walletByVid.bind(this);
        this.walletByVidChain = this.walletByVidChain.bind(this);
    }

    totalCreated = async (): Promise<Uint64> => {
        return this.client.queryContractSmart(this.contractAddress, {
            total_created: {},
        });
    };
    defaultProxyCodeId = async (): Promise<Uint64> => {
        return this.client.queryContractSmart(this.contractAddress, {
            default_proxy_code_id: {},
        });
    };
    deployer = async (): Promise<Addr> => {
        return this.client.queryContractSmart(this.contractAddress, {
            deployer: {},
        });
    };
    supportedChains = async ({
        limit,
        startAfter,
    }: {
        limit?: number;
        startAfter?: string;
    }): Promise<ArrayOfTupleOfStringAndChainConnection> => {
        return this.client.queryContractSmart(this.contractAddress, {
            supported_chains: {
                limit,
                start_after: startAfter,
            },
        });
    };
    supportedProxies = async ({
        limit,
        startAfter,
    }: {
        limit?: number;
        startAfter?: number;
    }): Promise<ArrayOfTupleOfUint64AndString> => {
        return this.client.queryContractSmart(this.contractAddress, {
            supported_proxies: {
                limit,
                start_after: startAfter,
            },
        });
    };
    fees = async (): Promise<FeesResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            fees: {},
        });
    };
    authProviderAddr = async ({ ty }: { ty: AuthenticatorType }): Promise<NullableAddr> => {
        return this.client.queryContractSmart(this.contractAddress, {
            auth_provider_addr: {
                ty,
            },
        });
    };
    contractVersion = async (): Promise<ContractVersion> => {
        return this.client.queryContractSmart(this.contractAddress, {
            contract_version: {},
        });
    };
    walletByVid = async ({ vid }: { vid: string }): Promise<NullableAddr> => {
        return this.client.queryContractSmart(this.contractAddress, {
            wallet_by_vid: {
                vid,
            },
        });
    };
    walletByVidChain = async ({ chainId, vid }: { chainId: string; vid: string }): Promise<NullableString> => {
        return this.client.queryContractSmart(this.contractAddress, {
            wallet_by_vid_chain: {
                chain_id: chainId,
                vid,
            },
        });
    };
}
export interface FactoryInterface extends FactoryReadOnlyInterface {
    contractAddress: string;
    sender: string;
    updateCodeId: (
        {
            codeId,
            setAsDefault,
            ty,
            version,
        }: {
            codeId: number;
            setAsDefault: boolean;
            ty: CodeIdType;
            version?: string;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        _funds?: Coin[]
    ) => Promise<ExecuteResult>;
    updateConfigFee: (
        {
            newFee,
            ty,
        }: {
            newFee: Coin;
            ty: FeeType;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        _funds?: Coin[]
    ) => Promise<ExecuteResult>;
    updateSupportedInterchain: (
        {
            chainConnection,
            chainId,
        }: {
            chainConnection?: ChainConnection;
            chainId: string;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        _funds?: Coin[]
    ) => Promise<ExecuteResult>;
    updateDeployer: (
        {
            addr,
        }: {
            addr: string;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        _funds?: Coin[]
    ) => Promise<ExecuteResult>;
    updateAuthProvider: (
        {
            newCodeId,
            newInstMsg,
            ty,
        }: {
            newCodeId?: number;
            newInstMsg?: Binary;
            ty: AuthenticatorType;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        _funds?: Coin[]
    ) => Promise<ExecuteResult>;
    createWallet: (
        {
            createWalletMsg,
        }: {
            createWalletMsg: CreateWalletMsg;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        _funds?: Coin[]
    ) => Promise<ExecuteResult>;
    migrateWallet: (
        {
            migrationsMsg,
        }: {
            migrationsMsg: MigrateWalletMsg;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        _funds?: Coin[]
    ) => Promise<ExecuteResult>;
}
export class FactoryClient extends FactoryQueryClient implements FactoryInterface {
    override client: SigningCosmWasmClient;
    sender: string;
    override contractAddress: string;

    constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
        super(client, contractAddress);
        this.client = client;
        this.sender = sender;
        this.contractAddress = contractAddress;
        this.updateCodeId = this.updateCodeId.bind(this);
        this.updateConfigFee = this.updateConfigFee.bind(this);
        this.updateSupportedInterchain = this.updateSupportedInterchain.bind(this);
        this.updateDeployer = this.updateDeployer.bind(this);
        this.updateAuthProvider = this.updateAuthProvider.bind(this);
        this.createWallet = this.createWallet.bind(this);
        this.migrateWallet = this.migrateWallet.bind(this);
    }

    updateCodeId = async (
        {
            codeId,
            setAsDefault,
            ty,
            version,
        }: {
            codeId: number;
            setAsDefault: boolean;
            ty: CodeIdType;
            version?: string;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        _funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                update_code_id: {
                    code_id: codeId,
                    set_as_default: setAsDefault,
                    ty,
                    version,
                },
            },
            fee,
            memo,
            _funds
        );
    };
    updateConfigFee = async (
        {
            newFee,
            ty,
        }: {
            newFee: Coin;
            ty: FeeType;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        _funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                update_config_fee: {
                    new_fee: newFee,
                    ty,
                },
            },
            fee,
            memo,
            _funds
        );
    };
    updateSupportedInterchain = async (
        {
            chainConnection,
            chainId,
        }: {
            chainConnection?: ChainConnection;
            chainId: string;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        _funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                update_supported_interchain: {
                    chain_connection: chainConnection,
                    chain_id: chainId,
                },
            },
            fee,
            memo,
            _funds
        );
    };
    updateDeployer = async (
        {
            addr,
        }: {
            addr: string;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        _funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                update_deployer: {
                    addr,
                },
            },
            fee,
            memo,
            _funds
        );
    };
    updateAuthProvider = async (
        {
            newCodeId,
            newInstMsg,
            ty,
        }: {
            newCodeId?: number;
            newInstMsg?: Binary;
            ty: AuthenticatorType;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        _funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                update_auth_provider: {
                    new_code_id: newCodeId,
                    new_inst_msg: newInstMsg,
                    ty,
                },
            },
            fee,
            memo,
            _funds
        );
    };
    createWallet = async (
        {
            createWalletMsg,
        }: {
            createWalletMsg: CreateWalletMsg;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        _funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                create_wallet: {
                    create_wallet_msg: createWalletMsg,
                },
            },
            fee,
            memo,
            _funds
        );
    };
    migrateWallet = async (
        {
            migrationsMsg,
        }: {
            migrationsMsg: MigrateWalletMsg;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        _funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                migrate_wallet: {
                    migrations_msg: migrationsMsg,
                },
            },
            fee,
            memo,
            _funds
        );
    };
}
