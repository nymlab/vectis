/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.26.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import {
    InstantiateMsg,
    ExecuteMsg,
    ExecMsg,
    RefillLimit,
    Uint128,
    CosmosMsgForEmpty,
    BankMsg,
    StakingMsg,
    DistributionMsg,
    Binary,
    IbcMsg,
    Timestamp,
    Uint64,
    WasmMsg,
    GovMsg,
    VoteOption,
    Boundary,
    Interval,
    CosmosQueryForWasmQuery,
    WasmQuery,
    ValueIndex,
    PathToValue,
    AutoRefill,
    TaskRequest,
    ActionForEmpty,
    Coin,
    Empty,
    IbcTimeout,
    IbcTimeoutBlock,
    BoundaryHeight,
    BoundaryTime,
    Cw20Coin,
    CroncatQuery,
    Transform,
    QueryMsg,
    QueryMsg1,
    Addr,
    CronKittyActionResp,
    RefillAccounting,
} from "./CronKitty.types";
export interface CronKittyReadOnlyInterface {
    contractAddress: string;
    actionId: () => Promise<Uint64>;
    action: ({ actionId }: { actionId: number }) => Promise<CronKittyActionResp>;
}
export class CronKittyQueryClient implements CronKittyReadOnlyInterface {
    client: CosmWasmClient;
    contractAddress: string;

    constructor(client: CosmWasmClient, contractAddress: string) {
        this.client = client;
        this.contractAddress = contractAddress;
        this.actionId = this.actionId.bind(this);
        this.action = this.action.bind(this);
    }

    actionId = async (): Promise<Uint64> => {
        return this.client.queryContractSmart(this.contractAddress, {
            action_id: {},
        });
    };
    action = async ({ actionId }: { actionId: number }): Promise<CronKittyActionResp> => {
        return this.client.queryContractSmart(this.contractAddress, {
            action: {
                action_id: actionId,
            },
        });
    };
}
export interface CronKittyInterface extends CronKittyReadOnlyInterface {
    contractAddress: string;
    sender: string;
    execute: (
        {
            actionId,
        }: {
            actionId: number;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: Coin[]
    ) => Promise<ExecuteResult>;
    createTask: (
        {
            autoRefill,
            task,
        }: {
            autoRefill?: AutoRefill;
            task: TaskRequest;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: Coin[]
    ) => Promise<ExecuteResult>;
    removeTask: (
        {
            taskId,
        }: {
            taskId: number;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: Coin[]
    ) => Promise<ExecuteResult>;
    withdrawFunds: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    refillTask: (
        {
            taskId,
        }: {
            taskId: number;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: Coin[]
    ) => Promise<ExecuteResult>;
}
export class CronKittyClient extends CronKittyQueryClient implements CronKittyInterface {
    override client: SigningCosmWasmClient;
    sender: string;
    override contractAddress: string;

    constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
        super(client, contractAddress);
        this.client = client;
        this.sender = sender;
        this.contractAddress = contractAddress;
        this.execute = this.execute.bind(this);
        this.createTask = this.createTask.bind(this);
        this.removeTask = this.removeTask.bind(this);
        this.withdrawFunds = this.withdrawFunds.bind(this);
        this.refillTask = this.refillTask.bind(this);
    }

    execute = async (
        {
            actionId,
        }: {
            actionId: number;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                execute: {
                    action_id: actionId,
                },
            },
            fee,
            memo,
            funds
        );
    };
    createTask = async (
        {
            autoRefill,
            task,
        }: {
            autoRefill?: AutoRefill;
            task: TaskRequest;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                create_task: {
                    auto_refill: autoRefill,
                    task,
                },
            },
            fee,
            memo,
            funds
        );
    };
    removeTask = async (
        {
            taskId,
        }: {
            taskId: number;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                remove_task: {
                    task_id: taskId,
                },
            },
            fee,
            memo,
            funds
        );
    };
    withdrawFunds = async (
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                withdraw_funds: {},
            },
            fee,
            memo,
            funds
        );
    };
    refillTask = async (
        {
            taskId,
        }: {
            taskId: number;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                refill_task: {
                    task_id: taskId,
                },
            },
            fee,
            memo,
            funds
        );
    };
}
