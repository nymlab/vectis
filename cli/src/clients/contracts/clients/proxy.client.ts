/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { AuthenticatorProvider, AuthenticatorType, Binary, Uint128, PluginPermission, PluginSource, InstantiateMsg, ProxyCreateMsg, CreateWalletMsg, Entity, Authenticator, PluginInstallParams, Coin, ExecuteMsg, WalletTraitExecMsg, WalletPluginTraitExecMsg, CosmosMsgForEmpty, BankMsg, StakingMsg, DistributionMsg, IbcMsg, Timestamp, Uint64, WasmMsg, GovMsg, VoteOption, Decimal, ExecMsg, RelayTransaction, Empty, IbcTimeout, IbcTimeoutBlock, WeightedVoteOption, PluginMigrateParams, QueryMsg, WalletTraitQueryMsg, WalletPluginTraitQueryMsg, QueryMsg1, NullableBinary, Addr, WalletInfo, WalletAddrs, ContractVersion, PluginListResponse, PluginInfo } from "../types/proxy.type";
export interface ProxyReadOnlyInterface {
  contractAddress: string;
  info: () => Promise<WalletInfo>;
  data: ({
    key
  }: {
    key: Binary;
  }) => Promise<NullableBinary>;
  plugins: ({
    limit,
    startAfter,
    ty
  }: {
    limit?: number;
    startAfter?: string;
    ty: PluginPermission;
  }) => Promise<PluginListResponse>;
}
export class ProxyQueryClient implements ProxyReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.info = this.info.bind(this);
    this.data = this.data.bind(this);
    this.plugins = this.plugins.bind(this);
  }

  info = async (): Promise<WalletInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      info: {}
    });
  };
  data = async ({
    key
  }: {
    key: Binary;
  }): Promise<NullableBinary> => {
    return this.client.queryContractSmart(this.contractAddress, {
      data: {
        key
      }
    });
  };
  plugins = async ({
    limit,
    startAfter,
    ty
  }: {
    limit?: number;
    startAfter?: string;
    ty: PluginPermission;
  }): Promise<PluginListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      plugins: {
        limit,
        start_after: startAfter,
        ty
      }
    });
  };
}
export interface ProxyInterface extends ProxyReadOnlyInterface {
  contractAddress: string;
  sender: string;
  controllerRotation: ({
    newController
  }: {
    newController: Entity;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  authExec: ({
    transaction
  }: {
    transaction: RelayTransaction;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  authExecWithoutPlugins: ({
    transaction
  }: {
    transaction: RelayTransaction;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  controllerNonceUpdate: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateData: ({
    data
  }: {
    data: Binary[][];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  pluginExecute: ({
    msg
  }: {
    msg: CosmosMsgForEmpty[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  installPlugins: ({
    install
  }: {
    install: PluginInstallParams[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updatePlugins: ({
    migrate
  }: {
    migrate: PluginMigrateParams[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removePlugins: ({
    pluginAddrs
  }: {
    pluginAddrs: string[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class ProxyClient extends ProxyQueryClient implements ProxyInterface {
  override client: SigningCosmWasmClient;
  sender: string;
  override contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.controllerRotation = this.controllerRotation.bind(this);
    this.authExec = this.authExec.bind(this);
    this.authExecWithoutPlugins = this.authExecWithoutPlugins.bind(this);
    this.controllerNonceUpdate = this.controllerNonceUpdate.bind(this);
    this.updateData = this.updateData.bind(this);
    this.pluginExecute = this.pluginExecute.bind(this);
    this.installPlugins = this.installPlugins.bind(this);
    this.updatePlugins = this.updatePlugins.bind(this);
    this.removePlugins = this.removePlugins.bind(this);
  }

  controllerRotation = async ({
    newController
  }: {
    newController: Entity;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      controller_rotation: {
        new_controller: newController
      }
    }, fee, memo, _funds);
  };
  authExec = async ({
    transaction
  }: {
    transaction: RelayTransaction;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      auth_exec: {
        transaction
      }
    }, fee, memo, _funds);
  };
  authExecWithoutPlugins = async ({
    transaction
  }: {
    transaction: RelayTransaction;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      auth_exec_without_plugins: {
        transaction
      }
    }, fee, memo, _funds);
  };
  controllerNonceUpdate = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      controller_nonce_update: {}
    }, fee, memo, _funds);
  };
  updateData = async ({
    data
  }: {
    data: Binary[][];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_data: {
        data
      }
    }, fee, memo, _funds);
  };
  pluginExecute = async ({
    msg
  }: {
    msg: CosmosMsgForEmpty[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      plugin_execute: {
        msg
      }
    }, fee, memo, _funds);
  };
  installPlugins = async ({
    install
  }: {
    install: PluginInstallParams[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      install_plugins: {
        install
      }
    }, fee, memo, _funds);
  };
  updatePlugins = async ({
    migrate
  }: {
    migrate: PluginMigrateParams[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_plugins: {
        migrate
      }
    }, fee, memo, _funds);
  };
  removePlugins = async ({
    pluginAddrs
  }: {
    pluginAddrs: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_plugins: {
        plugin_addrs: pluginAddrs
      }
    }, fee, memo, _funds);
  };
}