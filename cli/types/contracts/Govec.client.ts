/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.10.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import {
    AllAccountsResponse,
    Uint128,
    BalanceResponse,
    Binary,
    DaoResponse,
    DownloadLogoResponse,
    ExecuteMsg,
    Logo,
    EmbeddedLogo,
    MinterData,
    LogoInfo,
    Addr,
    InstantiateMsg,
    Cw20Coin,
    MarketingInfoResponse,
    MinterResponse,
    QueryMsg,
    StakingResponse,
    TokenInfoResponse,
} from "./Govec.types";
export interface GovecReadOnlyInterface {
    contractAddress: string;
    balance: ({ address }: { address: string }) => Promise<BalanceResponse>;
    tokenInfo: () => Promise<TokenInfoResponse>;
    minter: () => Promise<MinterResponse>;
    staking: () => Promise<StakingResponse>;
    dao: () => Promise<DaoResponse>;
    allAccounts: ({ limit, startAfter }: { limit?: number; startAfter?: string }) => Promise<AllAccountsResponse>;
    marketingInfo: () => Promise<MarketingInfoResponse>;
    downloadLogo: () => Promise<DownloadLogoResponse>;
}
export class GovecQueryClient implements GovecReadOnlyInterface {
    client: CosmWasmClient;
    contractAddress: string;

    constructor(client: CosmWasmClient, contractAddress: string) {
        this.client = client;
        this.contractAddress = contractAddress;
        this.balance = this.balance.bind(this);
        this.tokenInfo = this.tokenInfo.bind(this);
        this.minter = this.minter.bind(this);
        this.staking = this.staking.bind(this);
        this.dao = this.dao.bind(this);
        this.allAccounts = this.allAccounts.bind(this);
        this.marketingInfo = this.marketingInfo.bind(this);
        this.downloadLogo = this.downloadLogo.bind(this);
    }

    balance = async ({ address }: { address: string }): Promise<BalanceResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            balance: {
                address,
            },
        });
    };
    tokenInfo = async (): Promise<TokenInfoResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            token_info: {},
        });
    };
    minter = async (): Promise<MinterResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            minter: {},
        });
    };
    staking = async (): Promise<StakingResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            staking: {},
        });
    };
    dao = async (): Promise<DaoResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            dao: {},
        });
    };
    allAccounts = async ({
        limit,
        startAfter,
    }: {
        limit?: number;
        startAfter?: string;
    }): Promise<AllAccountsResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            all_accounts: {
                limit,
                start_after: startAfter,
            },
        });
    };
    marketingInfo = async (): Promise<MarketingInfoResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            marketing_info: {},
        });
    };
    downloadLogo = async (): Promise<DownloadLogoResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            download_logo: {},
        });
    };
}
export interface GovecInterface extends GovecReadOnlyInterface {
    contractAddress: string;
    sender: string;
    transfer: (
        {
            amount,
            recipient,
        }: {
            amount: Uint128;
            recipient: string;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: Coin[]
    ) => Promise<ExecuteResult>;
    burn: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    send: (
        {
            amount,
            contract,
            msg,
        }: {
            amount: Uint128;
            contract: string;
            msg: Binary;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: Coin[]
    ) => Promise<ExecuteResult>;
    mint: (
        {
            newWallet,
        }: {
            newWallet: string;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: Coin[]
    ) => Promise<ExecuteResult>;
    updateStakingAddr: (
        {
            newAddr,
        }: {
            newAddr: string;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: Coin[]
    ) => Promise<ExecuteResult>;
    updateMintData: (
        {
            newMint,
        }: {
            newMint?: MinterData;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: Coin[]
    ) => Promise<ExecuteResult>;
    updateDaoAddr: (
        {
            newAddr,
        }: {
            newAddr: string;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: Coin[]
    ) => Promise<ExecuteResult>;
    updateMarketing: (
        {
            description,
            marketing,
            project,
        }: {
            description?: string;
            marketing?: string;
            project?: string;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: Coin[]
    ) => Promise<ExecuteResult>;
    uploadLogo: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class GovecClient extends GovecQueryClient implements GovecInterface {
    override client: SigningCosmWasmClient;
    sender: string;
    override contractAddress: string;

    constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
        super(client, contractAddress);
        this.client = client;
        this.sender = sender;
        this.contractAddress = contractAddress;
        this.transfer = this.transfer.bind(this);
        this.burn = this.burn.bind(this);
        this.send = this.send.bind(this);
        this.mint = this.mint.bind(this);
        this.updateStakingAddr = this.updateStakingAddr.bind(this);
        this.updateMintData = this.updateMintData.bind(this);
        this.updateDaoAddr = this.updateDaoAddr.bind(this);
        this.updateMarketing = this.updateMarketing.bind(this);
        this.uploadLogo = this.uploadLogo.bind(this);
    }

    transfer = async (
        {
            amount,
            recipient,
        }: {
            amount: Uint128;
            recipient: string;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                transfer: {
                    amount,
                    recipient,
                },
            },
            fee,
            memo,
            funds
        );
    };
    burn = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                burn: {},
            },
            fee,
            memo,
            funds
        );
    };
    send = async (
        {
            amount,
            contract,
            msg,
        }: {
            amount: Uint128;
            contract: string;
            msg: Binary;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                send: {
                    amount,
                    contract,
                    msg,
                },
            },
            fee,
            memo,
            funds
        );
    };
    mint = async (
        {
            newWallet,
        }: {
            newWallet: string;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                mint: {
                    new_wallet: newWallet,
                },
            },
            fee,
            memo,
            funds
        );
    };
    updateStakingAddr = async (
        {
            newAddr,
        }: {
            newAddr: string;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                update_staking_addr: {
                    new_addr: newAddr,
                },
            },
            fee,
            memo,
            funds
        );
    };
    updateMintData = async (
        {
            newMint,
        }: {
            newMint?: MinterData;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                update_mint_data: {
                    new_mint: newMint,
                },
            },
            fee,
            memo,
            funds
        );
    };
    updateDaoAddr = async (
        {
            newAddr,
        }: {
            newAddr: string;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                update_dao_addr: {
                    new_addr: newAddr,
                },
            },
            fee,
            memo,
            funds
        );
    };
    updateMarketing = async (
        {
            description,
            marketing,
            project,
        }: {
            description?: string;
            marketing?: string;
            project?: string;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                update_marketing: {
                    description,
                    marketing,
                    project,
                },
            },
            fee,
            memo,
            funds
        );
    };
    uploadLogo = async (
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                upload_logo: {},
            },
            fee,
            memo,
            funds
        );
    };
}
