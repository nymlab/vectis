/**
 * This file was automatically generated by cosmwasm-typescript-gen@0.2.14.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the cosmwasm-typescript-gen generate command to regenerate this file.
 */

import { CosmWasmClient, ExecuteResult, SigningCosmWasmClient } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
export interface AllAccountsResponse {
    accounts: string[];
    [k: string]: unknown;
}
export type Uint128 = string;
export interface BalanceResponse {
    balance: Uint128;
    [k: string]: unknown;
}
export type Binary = string;
export type DaoResponse = string;
export type Logo =
    | {
          url: string;
      }
    | {
          embedded: EmbeddedLogo;
      };
export type EmbeddedLogo =
    | {
          svg: Binary;
      }
    | {
          png: Binary;
      };
export interface InstantiateMsg {
    initial_balances: Cw20Coin[];
    marketing?: MarketingInfo | null;
    minter?: MinterData | null;
    name: string;
    staking_addr?: string | null;
    symbol: string;
    [k: string]: unknown;
}
export interface Cw20Coin {
    address: string;
    amount: Uint128;
    [k: string]: unknown;
}
export interface MarketingInfo {
    description?: string | null;
    logo?: Logo | null;
    marketing?: string | null;
    project?: string | null;
    [k: string]: unknown;
}
export interface MinterData {
    cap?: Uint128 | null;
    minter: string;
    [k: string]: unknown;
}
export interface MinterResponse {
    cap?: Uint128 | null;
    minter: string;
    [k: string]: unknown;
}
export type StakingResponse = string;
export interface TokenInfoResponse {
    decimals: number;
    name: string;
    symbol: string;
    total_supply: Uint128;
    [k: string]: unknown;
}
export interface GovecReadOnlyInterface {
    contractAddress: string;
    balance: ({ address }: { address: string }) => Promise<BalanceResponse>;
    tokenInfo: () => Promise<TokenInfoResponse>;
    minter: () => Promise<MinterResponse>;
    staking: () => Promise<StakingResponse>;
    dao: () => Promise<DaoResponse>;
    allAccounts: ({ limit, startAfter }: { limit?: number; startAfter?: string }) => Promise<AllAccountsResponse>;
}
export class GovecQueryClient implements GovecReadOnlyInterface {
    client: CosmWasmClient;
    contractAddress: string;

    constructor(client: CosmWasmClient, contractAddress: string) {
        this.client = client;
        this.contractAddress = contractAddress;
        this.balance = this.balance.bind(this);
        this.tokenInfo = this.tokenInfo.bind(this);
        this.minter = this.minter.bind(this);
        this.staking = this.staking.bind(this);
        this.dao = this.dao.bind(this);
        this.allAccounts = this.allAccounts.bind(this);
    }

    balance = async ({ address }: { address: string }): Promise<BalanceResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            balance: {
                address,
            },
        });
    };
    tokenInfo = async (): Promise<TokenInfoResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            token_info: {},
        });
    };
    minter = async (): Promise<MinterResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            minter: {},
        });
    };
    staking = async (): Promise<StakingResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            staking: {},
        });
    };
    dao = async (): Promise<DaoResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            dao: {},
        });
    };
    allAccounts = async ({
        limit,
        startAfter,
    }: {
        limit?: number;
        startAfter?: string;
    }): Promise<AllAccountsResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            all_accounts: {
                limit,
                start_after: startAfter,
            },
        });
    };
}
export interface GovecInterface extends GovecReadOnlyInterface {
    contractAddress: string;
    sender: string;
    transfer: (
        {
            amount,
            recipient,
        }: {
            amount: Uint128;
            recipient: string;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: readonly Coin[]
    ) => Promise<ExecuteResult>;
    burn: (fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    send: (
        {
            amount,
            contract,
            msg,
        }: {
            amount: Uint128;
            contract: string;
            msg: Binary;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: readonly Coin[]
    ) => Promise<ExecuteResult>;
    mint: (
        {
            newWallet,
        }: {
            newWallet: string;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: readonly Coin[]
    ) => Promise<ExecuteResult>;
    updateStakingAddr: (
        {
            newAddr,
        }: {
            newAddr: string;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: readonly Coin[]
    ) => Promise<ExecuteResult>;
    updateMintData: (
        {
            newMint,
        }: {
            newMint?: MinterData;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: readonly Coin[]
    ) => Promise<ExecuteResult>;
    updateDaoAddr: (
        {
            newAddr,
        }: {
            newAddr: string;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        funds?: readonly Coin[]
    ) => Promise<ExecuteResult>;
}
export class GovecClient extends GovecQueryClient implements GovecInterface {
    override client: SigningCosmWasmClient;
    sender: string;
    override contractAddress: string;

    constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
        super(client, contractAddress);
        this.client = client;
        this.sender = sender;
        this.contractAddress = contractAddress;
        this.transfer = this.transfer.bind(this);
        this.burn = this.burn.bind(this);
        this.send = this.send.bind(this);
        this.mint = this.mint.bind(this);
        this.updateStakingAddr = this.updateStakingAddr.bind(this);
        this.updateMintData = this.updateMintData.bind(this);
        this.updateDaoAddr = this.updateDaoAddr.bind(this);
    }

    transfer = async (
        {
            amount,
            recipient,
        }: {
            amount: Uint128;
            recipient: string;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: readonly Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                transfer: {
                    amount,
                    recipient,
                },
            },
            fee,
            memo,
            funds
        );
    };
    burn = async (
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: readonly Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                burn: {},
            },
            fee,
            memo,
            funds
        );
    };
    send = async (
        {
            amount,
            contract,
            msg,
        }: {
            amount: Uint128;
            contract: string;
            msg: Binary;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: readonly Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                send: {
                    amount,
                    contract,
                    msg,
                },
            },
            fee,
            memo,
            funds
        );
    };
    mint = async (
        {
            newWallet,
        }: {
            newWallet: string;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: readonly Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                mint: {
                    new_wallet: newWallet,
                },
            },
            fee,
            memo,
            funds
        );
    };
    updateStakingAddr = async (
        {
            newAddr,
        }: {
            newAddr: string;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: readonly Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                update_staking_addr: {
                    new_addr: newAddr,
                },
            },
            fee,
            memo,
            funds
        );
    };
    updateMintData = async (
        {
            newMint,
        }: {
            newMint?: MinterData;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: readonly Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                update_mint_data: {
                    new_mint: newMint,
                },
            },
            fee,
            memo,
            funds
        );
    };
    updateDaoAddr = async (
        {
            newAddr,
        }: {
            newAddr: string;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        funds?: readonly Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                update_dao_addr: {
                    new_addr: newAddr,
                },
            },
            fee,
            memo,
            funds
        );
    };
}
