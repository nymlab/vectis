/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.35.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import {
    Uint128,
    SubscriptionTier,
    Duration,
    InstantiateMsg,
    Coin,
    TierDetails,
    ExecuteMsg,
    RegistryServiceTraitExecMsg,
    RegistryManagementTraitExecMsg,
    ExecMsg,
    PluginCodeData,
    PluginMetadataData,
    QueryMsg,
    RegistryServiceTraitQueryMsg,
    RegistryManagementTraitQueryMsg,
    QueryMsg1,
    ContractVersion,
    RegistryConfigResponse,
    CanonicalAddr,
    Binary,
    PluginWithVersionResponse,
    Plugin,
    VersionDetails,
    NullablePlugin,
    PluginsResponse,
    NullableSubscriber,
    Expiration,
    Timestamp,
    Uint64,
    Subscriber,
} from "./PluginRegistry.types";
export interface PluginRegistryReadOnlyInterface {
    contractAddress: string;
    subsciptionDetails: ({ addr }: { addr: string }) => Promise<NullableSubscriber>;
    getPlugins: ({ limit, startAfter }: { limit?: number; startAfter?: number }) => Promise<PluginsResponse>;
    getPluginById: ({ id }: { id: number }) => Promise<NullablePlugin>;
    getPluginByAddress: ({ contractAddr }: { contractAddr: string }) => Promise<PluginWithVersionResponse>;
    getConfig: () => Promise<RegistryConfigResponse>;
    contractVersion: () => Promise<ContractVersion>;
}
export class PluginRegistryQueryClient implements PluginRegistryReadOnlyInterface {
    client: CosmWasmClient;
    contractAddress: string;

    constructor(client: CosmWasmClient, contractAddress: string) {
        this.client = client;
        this.contractAddress = contractAddress;
        this.subsciptionDetails = this.subsciptionDetails.bind(this);
        this.getPlugins = this.getPlugins.bind(this);
        this.getPluginById = this.getPluginById.bind(this);
        this.getPluginByAddress = this.getPluginByAddress.bind(this);
        this.getConfig = this.getConfig.bind(this);
        this.contractVersion = this.contractVersion.bind(this);
    }

    subsciptionDetails = async ({ addr }: { addr: string }): Promise<NullableSubscriber> => {
        return this.client.queryContractSmart(this.contractAddress, {
            subsciption_details: {
                addr,
            },
        });
    };
    getPlugins = async ({ limit, startAfter }: { limit?: number; startAfter?: number }): Promise<PluginsResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            get_plugins: {
                limit,
                start_after: startAfter,
            },
        });
    };
    getPluginById = async ({ id }: { id: number }): Promise<NullablePlugin> => {
        return this.client.queryContractSmart(this.contractAddress, {
            get_plugin_by_id: {
                id,
            },
        });
    };
    getPluginByAddress = async ({ contractAddr }: { contractAddr: string }): Promise<PluginWithVersionResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            get_plugin_by_address: {
                contract_addr: contractAddr,
            },
        });
    };
    getConfig = async (): Promise<RegistryConfigResponse> => {
        return this.client.queryContractSmart(this.contractAddress, {
            get_config: {},
        });
    };
    contractVersion = async (): Promise<ContractVersion> => {
        return this.client.queryContractSmart(this.contractAddress, {
            contract_version: {},
        });
    };
}
export interface PluginRegistryInterface extends PluginRegistryReadOnlyInterface {
    contractAddress: string;
    sender: string;
    proxyInstallPlugin: (
        {
            id,
        }: {
            id: number;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        _funds?: Coin[]
    ) => Promise<ExecuteResult>;
    proxyRemovePlugin: (
        {
            id,
        }: {
            id: number;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        _funds?: Coin[]
    ) => Promise<ExecuteResult>;
    subscribe: (
        {
            tier,
        }: {
            tier: SubscriptionTier;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        _funds?: Coin[]
    ) => Promise<ExecuteResult>;
    registerPlugin: (
        {
            codeData,
            metadataData,
        }: {
            codeData: PluginCodeData;
            metadataData: PluginMetadataData;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        _funds?: Coin[]
    ) => Promise<ExecuteResult>;
    unregisterPlugin: (
        {
            id,
        }: {
            id: number;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        _funds?: Coin[]
    ) => Promise<ExecuteResult>;
    newPluginVersion: (
        {
            codeUpdate,
            id,
            metadataUpdate,
        }: {
            codeUpdate?: PluginCodeData;
            id: number;
            metadataUpdate: PluginMetadataData;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        _funds?: Coin[]
    ) => Promise<ExecuteResult>;
    updateRegistryFee: (
        {
            newFee,
        }: {
            newFee: Coin;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        _funds?: Coin[]
    ) => Promise<ExecuteResult>;
    addSubscriptionTiers: (
        {
            details,
            tier,
        }: {
            details: TierDetails;
            tier: number;
        },
        fee?: number | StdFee | "auto",
        memo?: string,
        _funds?: Coin[]
    ) => Promise<ExecuteResult>;
}
export class PluginRegistryClient extends PluginRegistryQueryClient implements PluginRegistryInterface {
    override client: SigningCosmWasmClient;
    sender: string;
    override contractAddress: string;

    constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
        super(client, contractAddress);
        this.client = client;
        this.sender = sender;
        this.contractAddress = contractAddress;
        this.proxyInstallPlugin = this.proxyInstallPlugin.bind(this);
        this.proxyRemovePlugin = this.proxyRemovePlugin.bind(this);
        this.subscribe = this.subscribe.bind(this);
        this.registerPlugin = this.registerPlugin.bind(this);
        this.unregisterPlugin = this.unregisterPlugin.bind(this);
        this.newPluginVersion = this.newPluginVersion.bind(this);
        this.updateRegistryFee = this.updateRegistryFee.bind(this);
        this.addSubscriptionTiers = this.addSubscriptionTiers.bind(this);
    }

    proxyInstallPlugin = async (
        {
            id,
        }: {
            id: number;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        _funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                proxy_install_plugin: {
                    id,
                },
            },
            fee,
            memo,
            _funds
        );
    };
    proxyRemovePlugin = async (
        {
            id,
        }: {
            id: number;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        _funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                proxy_remove_plugin: {
                    id,
                },
            },
            fee,
            memo,
            _funds
        );
    };
    subscribe = async (
        {
            tier,
        }: {
            tier: SubscriptionTier;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        _funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                subscribe: {
                    tier,
                },
            },
            fee,
            memo,
            _funds
        );
    };
    registerPlugin = async (
        {
            codeData,
            metadataData,
        }: {
            codeData: PluginCodeData;
            metadataData: PluginMetadataData;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        _funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                register_plugin: {
                    code_data: codeData,
                    metadata_data: metadataData,
                },
            },
            fee,
            memo,
            _funds
        );
    };
    unregisterPlugin = async (
        {
            id,
        }: {
            id: number;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        _funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                unregister_plugin: {
                    id,
                },
            },
            fee,
            memo,
            _funds
        );
    };
    newPluginVersion = async (
        {
            codeUpdate,
            id,
            metadataUpdate,
        }: {
            codeUpdate?: PluginCodeData;
            id: number;
            metadataUpdate: PluginMetadataData;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        _funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                new_plugin_version: {
                    code_update: codeUpdate,
                    id,
                    metadata_update: metadataUpdate,
                },
            },
            fee,
            memo,
            _funds
        );
    };
    updateRegistryFee = async (
        {
            newFee,
        }: {
            newFee: Coin;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        _funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                update_registry_fee: {
                    new_fee: newFee,
                },
            },
            fee,
            memo,
            _funds
        );
    };
    addSubscriptionTiers = async (
        {
            details,
            tier,
        }: {
            details: TierDetails;
            tier: number;
        },
        fee: number | StdFee | "auto" = "auto",
        memo?: string,
        _funds?: Coin[]
    ): Promise<ExecuteResult> => {
        return await this.client.execute(
            this.sender,
            this.contractAddress,
            {
                add_subscription_tiers: {
                    details,
                    tier,
                },
            },
            fee,
            memo,
            _funds
        );
    };
}
